package solver

import (
	"github.com/behrlich/poker-solver/pkg/tree"
)

// BestResponse calculates the best response strategy against a fixed opponent strategy
type BestResponse struct {
	profile        *StrategyProfile
	opponentPlayer int // Which player's strategy is fixed (0 or 1)
	bestValues     map[string]float64
}

// NewBestResponse creates a new best response calculator
func NewBestResponse(profile *StrategyProfile, opponentPlayer int) *BestResponse {
	return &BestResponse{
		profile:        profile,
		opponentPlayer: opponentPlayer,
		bestValues:     make(map[string]float64),
	}
}

// CalculateBestResponse computes the best response EV for the exploiting player
// This walks the tree with the opponent playing their average strategy,
// and the exploiting player choosing actions that maximize EV
func (br *BestResponse) CalculateBestResponse(node *tree.TreeNode) float64 {
	exploitingPlayer := 1 - br.opponentPlayer

	return br.bestResponse(node, exploitingPlayer)
}

// bestResponse recursively computes best response EV
func (br *BestResponse) bestResponse(node *tree.TreeNode, exploitingPlayer int) float64 {
	// Terminal node: return payoff for exploiting player
	if node.IsTerminal {
		return node.Payoff[exploitingPlayer]
	}

	// Chance node: compute expected value over outcomes
	if node.IsChance {
		ev := 0.0
		for outcome, child := range node.Children {
			prob := node.ChanceProbabilities[outcome]
			ev += prob * br.bestResponse(child, exploitingPlayer)
		}
		return ev
	}

	// Decision node
	if len(node.Actions) == 0 {
		// No actions available - shouldn't happen in a well-formed tree
		return 0.0
	}

	if node.Player == exploitingPlayer {
		// Exploiting player: choose action that maximizes EV (best response)
		maxEV := -1e9
		for _, child := range node.Children {
			childEV := br.bestResponse(child, exploitingPlayer)
			if childEV > maxEV {
				maxEV = childEV
			}
		}
		return maxEV
	} else {
		// Opponent player: play according to average strategy from profile
		strategy, exists := br.profile.Get(node.InfoSet)
		if !exists || len(strategy.Actions) == 0 {
			// No strategy found - assume uniform distribution
			ev := 0.0
			numActions := float64(len(node.Children))
			if numActions == 0 {
				return 0.0
			}
			for _, child := range node.Children {
				ev += (1.0 / numActions) * br.bestResponse(child, exploitingPlayer)
			}
			return ev
		}

		avgStrategy := strategy.GetAverageStrategy()
		ev := 0.0
		for i, action := range node.Actions {
			if i >= len(avgStrategy) {
				break
			}
			actionKey := tree.ActionKey(action)
			child, exists := node.Children[actionKey]
			if !exists {
				continue
			}
			ev += avgStrategy[i] * br.bestResponse(child, exploitingPlayer)
		}
		return ev
	}
}

// CalculateExploitability computes how exploitable the strategy profile is
// Exploitability is the sum of how much each player can gain by best-responding
// to the opponent's strategy, divided by 2
func CalculateExploitability(profile *StrategyProfile, root *tree.TreeNode) float64 {
	// Calculate best response EV for player 0 against player 1's strategy
	br0 := NewBestResponse(profile, 1) // P1's strategy is fixed
	p0BestEV := br0.CalculateBestResponse(root)

	// Calculate best response EV for player 1 against player 0's strategy
	br1 := NewBestResponse(profile, 0) // P0's strategy is fixed
	p1BestEV := br1.CalculateBestResponse(root)

	// In a zero-sum game, Nash equilibrium has value 0 for P0 (assuming symmetric setup)
	// Exploitability = (BR_P0 + BR_P1) / 2
	// But we need to account for the pot/expected value at Nash equilibrium

	// For simplicity, we compute exploitability as:
	// How much each player gains by best-responding compared to Nash
	// In a zero-sum game, if both play Nash, sum of payoffs is 0
	// If P0 best-responds against P1, P0 gains p0BestEV
	// If P1 best-responds against P0, P1 gains p1BestEV

	// Exploitability is the average of these gains
	exploitability := (p0BestEV + p1BestEV) / 2.0

	return exploitability
}
