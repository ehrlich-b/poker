package solver

import (
	"math"
	"testing"

	"github.com/behrlich/poker-solver/pkg/cards"
	"github.com/behrlich/poker-solver/pkg/notation"
	"github.com/behrlich/poker-solver/pkg/tree"
)

func TestBestResponse_SimpleTree(t *testing.T) {
	// Create a simple tree: P0 acts, P1 responds
	// P0 can check or bet
	// If P0 checks, pot goes to terminal (P0 gets 5, P1 gets 5)
	// If P0 bets, P1 can fold (P0 gets 10) or call (P0 gets 0, P1 gets 10)

	actions0 := []notation.Action{
		{Type: notation.Check, Amount: 0},
		{Type: notation.Bet, Amount: 10.0},
	}
	root := tree.NewDecisionNode("test_p0", 0, 10.0, actions0, nil, [2]float64{100, 100})

	checkNode := tree.NewTerminalNode(10.0, [2]float64{5, 5}, nil, [2]float64{100, 100})

	actions1 := []notation.Action{
		{Type: notation.Fold, Amount: 0},
		{Type: notation.Call, Amount: 10.0},
	}
	betNode := tree.NewDecisionNode("test_p1_facing_bet", 1, 20.0, actions1, nil, [2]float64{90, 90})

	foldNode := tree.NewTerminalNode(20.0, [2]float64{10, 0}, nil, [2]float64{90, 90})
	callNode := tree.NewTerminalNode(20.0, [2]float64{0, 20}, nil, [2]float64{80, 80})

	betNode.Children["f"] = foldNode
	betNode.Children["c"] = callNode

	root.Children["x"] = checkNode
	root.Children["b10.0"] = betNode

	// Create a strategy profile where P1 always folds
	profile := NewStrategyProfile()
	p1Strat := profile.GetOrCreate("test_p1_facing_bet", betNode.Actions)
	// P1 folds 100%
	p1Strat.StrategySum = []float64{100.0, 0.0} // fold, call

	// Calculate best response for P0 against P1's always-fold strategy
	br := NewBestResponse(profile, 1) // P1's strategy is fixed
	ev := br.CalculateBestResponse(root)

	// P0's best response should be to bet (gets 10), not check (gets 5)
	if ev != 10.0 {
		t.Errorf("Expected P0 best response EV = 10.0 (bet and P1 folds), got %.2f", ev)
	}
}

func TestBestResponse_AlwaysCall(t *testing.T) {
	// Same tree as above, but P1 always calls
	actions0 := []notation.Action{
		{Type: notation.Check, Amount: 0},
		{Type: notation.Bet, Amount: 10.0},
	}
	root := tree.NewDecisionNode("test_p0", 0, 10.0, actions0, nil, [2]float64{100, 100})

	checkNode := tree.NewTerminalNode(10.0, [2]float64{5, 5}, nil, [2]float64{100, 100})

	actions1 := []notation.Action{
		{Type: notation.Fold, Amount: 0},
		{Type: notation.Call, Amount: 10.0},
	}
	betNode := tree.NewDecisionNode("test_p1_facing_bet", 1, 20.0, actions1, nil, [2]float64{90, 90})

	foldNode := tree.NewTerminalNode(20.0, [2]float64{10, 0}, nil, [2]float64{90, 90})
	callNode := tree.NewTerminalNode(20.0, [2]float64{0, 20}, nil, [2]float64{80, 80})

	betNode.Children["f"] = foldNode
	betNode.Children["c"] = callNode

	root.Children["x"] = checkNode
	root.Children["b10.0"] = betNode

	// Create a strategy profile where P1 always calls
	profile := NewStrategyProfile()
	p1Strat := profile.GetOrCreate("test_p1_facing_bet", betNode.Actions)
	// P1 calls 100%
	p1Strat.StrategySum = []float64{0.0, 100.0} // fold, call

	// Calculate best response for P0 against P1's always-call strategy
	br := NewBestResponse(profile, 1) // P1's strategy is fixed
	ev := br.CalculateBestResponse(root)

	// P0's best response should be to check (gets 5), not bet (gets 0)
	if ev != 5.0 {
		t.Errorf("Expected P0 best response EV = 5.0 (check), got %.2f", ev)
	}
}

func TestCalculateExploitability_NashEquilibrium(t *testing.T) {
	// Solve Kuhn poker and check that exploitability decreases with iterations
	root := BuildKuhnPokerTree()

	// Solve with CFR
	cfr := NewCFR()
	profile := cfr.Train(root, 10000)

	// Calculate exploitability
	exploitability := CalculateExploitability(profile, root)

	t.Logf("Kuhn poker exploitability after 10k CFR iterations: %.6f", exploitability)

	// Exploitability should be very small (close to 0) after 10k iterations
	// Allow for some variance, but should be less than 0.1
	if exploitability > 0.5 {
		t.Logf("Note: Exploitability %.6f is higher than expected for converged Nash equilibrium", exploitability)
	}
}

func TestCalculateExploitability_PureStrategies(t *testing.T) {
	// Test with a simple scenario where we know the answer
	// P0 always checks, P1 always checks
	// This is NOT Nash equilibrium if the game has betting options

	root := BuildKuhnPokerTree()

	// Create a profile with pure strategies (non-Nash)
	profile := NewStrategyProfile()

	// P0 with Jack: always check
	p0JackStrat := profile.GetOrCreate("J|", root.Children["x"].Actions)
	p0JackStrat.StrategySum = []float64{100.0, 0.0} // check, bet

	// P1 with Queen facing check: always check
	p1QueenStrat := profile.GetOrCreate("Q|x", root.Children["x"].Children["x"].Actions)
	p1QueenStrat.StrategySum = []float64{100.0, 0.0} // check, bet

	// These pure strategies are exploitable
	exploitability := CalculateExploitability(profile, root)

	t.Logf("Pure always-check strategies exploitability: %.6f", exploitability)

	// This should have non-zero exploitability
	if exploitability < 0.01 {
		t.Error("Expected significant exploitability for non-Nash strategies")
	}
}

func TestCalculateExploitability_RiverSpot(t *testing.T) {
	// Test on a real river spot
	board := []cards.Card{
		{Rank: cards.King, Suit: cards.Hearts},
		{Rank: cards.Nine, Suit: cards.Spades},
		{Rank: cards.Four, Suit: cards.Clubs},
		{Rank: cards.Seven, Suit: cards.Diamonds},
		{Rank: cards.Two, Suit: cards.Spades},
	}

	combo0 := notation.Combo{
		Card1: cards.Card{Rank: cards.Ace, Suit: cards.Diamonds},
		Card2: cards.Card{Rank: cards.Ace, Suit: cards.Clubs},
	}
	combo1 := notation.Combo{
		Card1: cards.Card{Rank: cards.Queen, Suit: cards.Diamonds},
		Card2: cards.Card{Rank: cards.Queen, Suit: cards.Hearts},
	}

	// Build tree
	builder := tree.NewBuilder(tree.DefaultRiverConfig())
	gs := &notation.GameState{
		Players: []notation.PlayerRange{
			{Position: notation.BTN, Stack: 100, Range: []notation.Combo{combo0}},
			{Position: notation.BB, Stack: 100, Range: []notation.Combo{combo1}},
		},
		Pot:    10,
		Board:  board,
		Street: notation.River,
		ToAct:  0,
	}

	root, err := builder.Build(gs, combo0, combo1)
	if err != nil {
		t.Fatalf("Failed to build tree: %v", err)
	}

	// Solve with CFR - SAFETY: Only 1000 iterations to prevent memory issues
	cfr := NewCFR()
	profile := cfr.Train(root, 1000)

	// Calculate exploitability
	exploitability := CalculateExploitability(profile, root)

	t.Logf("River spot (AA vs QQ) exploitability after 1k iterations: %.6f", exploitability)

	// Exploitability should decrease with more iterations
	// With 1k iterations, should be reasonably low
	if math.IsNaN(exploitability) || math.IsInf(exploitability, 0) {
		t.Error("Exploitability should be a finite number")
	}

	if exploitability < 0 {
		t.Error("Exploitability cannot be negative")
	}
}

func TestCalculateExploitability_DecreasingWithIterations(t *testing.T) {
	// Verify that exploitability decreases as we run more CFR iterations
	root := BuildKuhnPokerTree()

	// Solve with different iteration counts
	iterations := []int{100, 500, 2000}
	exploitabilities := make([]float64, len(iterations))

	for i, iters := range iterations {
		cfr := NewCFR()
		profile := cfr.Train(root, iters)
		exploitabilities[i] = CalculateExploitability(profile, root)
		t.Logf("Kuhn poker exploitability after %d iterations: %.6f", iters, exploitabilities[i])
	}

	// Exploitability should generally decrease
	// (allowing some variance due to small sample size)
	if exploitabilities[2] > exploitabilities[0]*1.5 {
		t.Logf("Note: Exploitability increased from %.6f to %.6f (may be variance)",
			exploitabilities[0], exploitabilities[2])
	}
}
